---
title: How Networks Works
date: 2020-06-27 21:29:16
tags: Network
---

## 浏览器生成消息—浏览器内部

![](/images/HowNetworksWorks/1.png)

### 生成 HTTP 请求消息

#### 解析 URL
- URL:Uniform Resource Locator
- FTP:File Transfer Protocol

![](/images/HowNetworksWorks/2.png)

- 协议：通信操作的规则
- URL 开头部分，表示浏览器应当使用的方法；比如：http,ftp,file,mailto
- Web浏览器解析 URL 过程
    - ![](/images/HowNetworksWorks/3.png)
    - ![](/images/HowNetworksWorks/4.png)

#### URL 省略
- `http://www.lab.glasscom.com/dir/`
    - 像这个 URL 其实背后省略了具体文件
    - 一般服务器上会事先设置好文件名省略时要访问的默认文件名
    - 根据不同的服务器而不同，大多数情况是 index.html 之类
    - 完整的访问地址为 `http://www.lab.glasscom.com/dir/index.html`

- `http:/www.lab.glasscom.com/` 
    - 这种也是省略了的; 一般情况完整为 `http:?/www.lab.glasscom.com/index.html`
    - 其实以 “/” 结尾，表示它访问了名为 “/” 的目录; “/” 顶级目录，根目录
    - 前面的 dir/ 就是访问 dir目录下的内容

- `http:/www.lab.glasscom.com` 
    - 这个连根目录 “/” 也省略了
    - 连目录都不知道的情况下,也就是没有路径名的情况下；一般代表访问根目录下事先设置的默认文件

- `http:/www.lab.glasscom.com/whatisthis`
    - 这种情况，可能是末尾 “/” 省略了，可也能没省略 ;事实上是很多人没有正确理解省略文件名的规则，经常把目录结尾的 “/” 省略了
    - 这种情况应该按照以下处理
    - 如果 Web 服务器上存在名为 whatisthis 的文件,则将它作为文件名处理
    - 如果存在名为 whatisthis 的目录，则当作目录名来处理
    - Linux 下无法创建两个名字相同的文件和目录；因此不可能既有一个名为 whatisthis 的文件，同时又有一个名为 whatisthis 的目录

#### HTTP 基本思路

![](/images/HowNetworksWorks/5.png)

- URI:Uniform Resource Identifier
- 一般来说，URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名，例如“/dir1/file1.html”“/dir1/program1.cgi”等
- 不过，URI 不仅限于此，也可以直接使用“http:”开头的 URL来作为 URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为 URI
- CGI 程序：对 Web 服务器程序调用其他程序的规则所做的定义就是 CGI，而按照 CGI 规范来工作的程序就称为 CGI 程序

- HTTP 的主要方法
![](/images/HowNetworksWorks/6.png)

- 请求/响应
![](/images/HowNetworksWorks/7.png)

![](/images/HowNetworksWorks/8.png)

![](/images/HowNetworksWorks/9.png)

![](/images/HowNetworksWorks/10.png)

![](/images/HowNetworksWorks/11.png)

- 一次请求响应过程
![](/images/HowNetworksWorks/12.png)

![](/images/HowNetworksWorks/13.png)

![](/images/HowNetworksWorks/14.png)

### 向 DNS 服务器查询 Web 服务器的 IP 地址

#### TCP/IP 结构思路
![](/images/HowNetworksWorks/15.png)

- 目前大部分路由器已经内置了集线器功能
- 数据是以包的形式传送的

- IP地址：一串 32 bit 的数字，按照 8 bit 为一组分成4组，分别用十进制表示
- 但单凭这串数字还是无法区分哪部分是网络号，哪部分是主机号

![](/images/HowNetworksWorks/16.png)

- 在IP地址的规则里，网络号加主机号总共是32bit，但是这两部分具体结构是不固定的
- 因此还要附加信息（子网掩码）来表示IP地址的内部结构

![](/images/HowNetworksWorks/17.png)

![](/images/HowNetworksWorks/18.png)

#### DNS 由来
- 确定通信对象需要知道它的IP地址
- 如果不知道通信对象的IP地址，就无法进行通信，需要事先查询记好
- 使用IP地址可以代替使用服务器名称（域名）去访问
- 但是如果通信对象的Web服务器使用了虚拟主机，有可能用IP地址访问不了
- 网络中存在无数的路由器，相互配合，根据IP地址来转发数据
- 用域名去访问对象比用IP去访问效率要低
- 因为IP地址长度32bit,4字节；而域名要几十字节；增加了路由器的负担，自然消耗的时间要更长
- 域名并不仅是长，而且其长度是不固定的。处理长度不固定的数据比处理长度固定的数据要复杂，这也是造成效率低下的重要原因之一
- （1）由于IP难以记住（2）使用域名效率低下
- 因此，使用了折中的方案：让人使用域名，路由器使用IP
- 为了达成这个目的，把域名和IP做关联的机制就诞生了，称为DNS:Domain Name System
- Domain Name System ：将服务器名称和 IP 地址进行关联是 DNS 最常见的用法，但 DNS 的功能并不仅限于此，它还可以将邮件地址和邮件服务器进行关联，以及为各种信息关联相应的名称

#### DNS 解析器
- 相对于DNS服务器，我们的计算机上一定有相应的DNS客户端（解析器），存在于操作系统的 Socket 库中

![](/images/HowNetworksWorks/19.png)

- 大概流程是
    - （1）使用DNS解析器把域名解析写入内存，接着交给操作系统向DNS服务器发送查询消息
    - （2）然后DNS服务器响应消息，解析器取出IP地址，存入浏览器指定的内存地址
    - （3）浏览器在向Web服务器发送请求的时候，从该内存地址取出IP地址，将它和HTTP请求一起提交给操作系统

![](/images/HowNetworksWorks/20.png)

- HTTP消息是用文本编写的，但DNS消息是使用二进制数据编写的
- 浏览器本身不具备使用网络收发数据的功能，都是由操作系统内部的协议栈（操作系统内部的网络控制软件，也叫协议驱动，TCP/IP驱动，等等）来执行的

- 向DNS服务器发送消息的时候，也是要知道DNS服务器的IP地址的，只不过这个IP地址作为TCP/IP的一个设置项目事先设置好了

![](/images/HowNetworksWorks/21.png)


### 全世界 DNS 服务器的大接力
#### DNS 基本工作
- 来自客户端解析器的查询信息
    - 域名
    - Class:以前设计的时候，还需要标识网络信息，不过现在除了互联网以外没有其他网络了
    - 记录类型:标识域名对应何种记录类型；比如 A(Address) 标识了域名对应的是IP地址、MX(Mail eXchange) 标识了对应邮件服务器

![](/images/HowNetworksWorks/22.png)

![](/images/HowNetworksWorks/23.png)

#### 域名层次结构

- 互联网中存在无数的服务器，将这些服务器信息存在一台DNS服务器是不可能的
- 因此，将信息分布保存在多台DNS服务器中，层层追溯
- www.lab.glasscom.com
    - 越靠右边，层级越高
    - www.lab.glasscom.com < lab.glasscom.com < glasscom.com < com
    - 每个层级可以称为域，每个域作为一个整体存放在DNS服务器中（但是，DNS服务器和域也并不总是一对一的）
    
- 互联网中那么多台DNS服务器，肯定不能挨个去找
- 因此，将下级域的IP地址注册到它们的上级域的DNS服务器中，就和链表，区块链一个意思
- 也就是说，负责管理 lab.glasscom.com 域的DNS服务器的IP地址注册到 glasscom.com 域的DNS服务器中，而 glasscom.com 域的DNS服务器的IP地址又注册到了 com 域的DNS服务器中
- 这样就可以从顶级开始层层追溯了
    - 目前来说，一般 com,jp 称为顶级域
    - 但是事实上它们上面还有一级域，称为根域
    - 根域并没有名字，因此常常被省略
    - www.lab.glasscom.com.  最后一个点就代表根域（和根目录一个思路）

![](/images/HowNetworksWorks/24.png)

- 根域的DNS服务器信息保存在全互联网所有DNS服务器中，这样一来就完成了
    - 分配给根域DNS服务器的IP地址在全世界只有13个，这些地址几乎不变化，所以就可以保存在所有DNS服务器中了
    - 根域 DNS 服务器在运营上使用多台服务器来对应一个 IP 地址，因此尽管 IP 地址只有 13 个，但其实服务器的数量是很多的

![](/images/HowNetworksWorks/25.png)

- 客户端计算机第一次访问的DNS服务器也就是我们在TCP/IP中设置的DNS服务器（所以改DNS也是有讲究的）
- 第一次访问的DNS服务器作为所有访问查询的中继点，如图所示

- 上图追溯只是基本原理，真实互联网一台DNS服务器可以管理多个域的信息，因此并不是每个域都有一台自己的DNS服务器
    - 现实中上下级域有可能共享同一台DNS服务器
    - 此外，有时候并不需要从最上级的根域开始查找，因为DNS服务器有个缓存功能
    - 缓存可以记住之前查询过的域名；
        - 如果要查询的域名和相关信息已经在缓存中，就可以直接从缓存的位置开始向下查询；减少查询时间
        - 并且，当要查询的域名信息不存在时，“不存在”这个响应结果也会被缓存；当下次查询这个不存在的域名时，也可以快速响应
        - 需要注意的是，信息被缓存后，原本的注册信息可能会发生改变，这时缓存的信息就有可能是不正确的
        - 因此，DNS服务器中保存的信息都会设置一个有效期；而且在查询响应时，DNS服务器也会告知客户端这个响应结果是来自缓存还是来自负责管理该域名的DNS服务器

### 委托协议栈发送信息

#### 数据收发操作概览
- 知道IP地址后，就可以委托操作系统内部的协议栈像这个目标IP地址，发送HTTP消息（数字消息）了

- 收发数字消息这个操作不局限于浏览器，对于各种使用网络的应用程序都是共通的

![](/images/HowNetworksWorks/26.png)

![](/images/HowNetworksWorks/27.png)

- 在收发数据操作之前，双方需要先建立连接（建立如图的假设出来的管道）
    - 建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字
    - 我们需要先创建套接字，然后再将套接字连接起来形成管道

- 实际上过程如下
    - 服务器一方先创建套接字，等待客户端向该套接字连接管道
    - 当服务器进入等待状态，客户端就可以连接管道了
    - 客户端也会先创建套接字，然后从该套接字延伸出管道，
    - 最后连接到服务器端的套接字上
    - 之后就可以收发数据了
    - 数据发送完毕后，断开时可以由任意一方发起

- 综上所述，可以总结为4个阶段
    - 创建套接字（创建套接字阶段）
    - 将管道连接到服务器段的套接字上（连接阶段）
    - 收发数据（通信阶段）
    - 断开管道并删除套接字（断开阶段）

- 以上的操作都是由操作系统内部的协议栈来执行的，浏览器和应用程序并不会自己去做这些工作，而是“委托”协议栈来做
- 这些“委托”都是通过调用 Socket库中的程序组件来执行的，这些数据通信用的组件充当了桥梁的角色

#### 创建套接字阶段

![](/images/HowNetworksWorks/28.png)

- 套接字创建完毕后，协议栈会返回一个描述符
- 应用程序会将收到的描述符存在内存中
- 描述符用来识别不同的套接字，因为实际上会有多个数据同时通信

#### 连接阶段

- 连接的时候还需要给出IP地址的具体端口号（表示具体哪个应用程序）
- 然后再从那个应用程序中找按照标识符找到对应的套接字

![](/images/HowNetworksWorks/29.png)

#### 通信阶段

- 连接完毕之后，接下来就通过 Sokcet库委托协议栈来将 应用程序在内存中准备好的数据 送入套接字
- 接着协议栈再将数据发送到服务器
- 服务器接收到数据后，执行相应的操作，再返回消息给客户端

#### 断开阶段

- Web 使用的HTTP协议规定，当Web服务器发送完响应消息后，应该主动断开操作
- HTTP协议将HTML文档和图片都作为单独对象处理，因此要执行很多次连接断开操作
- 所以后来HTTP 1.1 就可以在一次连接中收发多个请求响应


## 用电信号传输 TCP/IP 数据—协议栈、网卡

![](/images/HowNetworksWorks/30.png)

### 创建套接字

- 协议栈内部结构

![](/images/HowNetworksWorks/31.png)

![](/images/HowNetworksWorks/32.png)

- ICMP用于告知网络包传送过程中产生的错误以及各种控制消息
- ARP用于根据IP地址查询相应的以太网MAC地址

- 在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的进行状态等
    - 套接字只是一个概念而已，可以说这些控制信息就是套接字
    - 协议栈根据套接字的信息进行活动，这就是套接字的作用

- 下图的每一行相当于一个套接字
- PID:Process ID
![](/images/HowNetworksWorks/33.png)

- 下图是浏览器委托协议栈使用TCP协议来收发数据

![](/images/HowNetworksWorks/34.png)

- 协议栈首先会分配用于存放一个套接字所需的内存空间
- 然后向套接字的内存空间里写入表示这一初始状态的控制信息
- 这样一来套接字就创建完毕了

- 然后将这个套接字的描述符告诉应用程序；之后应用程序在向协议栈进行收发数据委托的时候就带着这个描述符，就能确定了相应的套接字，协议栈就能获取在相应套接字内相关的控制信息了

### 连接服务器

- “连接”是什么意思
    - 网线一直是连着的，随时都有信号从中流过，如果通信过程只是将数据转换为电信号，那么这个操作随时都可以进行
    - 套接字创建完成的时候，里面还没有任何存放任何控制信息，这种状态下即使应用程序要求发送数据，协议栈也不知道发送给谁
    - 协议栈需要等待我们在套接字中存入控制信息
    - 服务器程序一般会在系统启动的时候就创建套接字并等待客户端连接
    - 和客户端不同，服务器根本不知道想来通信的对象是谁
        - 就和打电话一样，对方在没接到电话之前，根本不可能知道打电话的人是谁
    - 连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作
    - 连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备

- 通信操作中使用的控制信息可以分为两大类
    - （1）客户端和服务器相互联络交换的控制信息
        - 这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程都需要
        - 这些内容在TCP协议中进行了定义
        - ![](/images/HowNetworksWorks/35.png)
        - 这些信息会添加在客户端和服务器之间传递的网络包头部（这里是TCP的控制信息，简称TCP头部）
            - 其他协议也有自己的控制信息，以太网头部（MAC头部），IP头部
        - ![](/images/HowNetworksWorks/36.png)
    - （2）保存在套接字中，用来控制协议操作的信息
        - 应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作
        - 我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的
        - “协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同，但无论协议栈的实现如何不同，IP地址和端口号这些重要的信息都是共通的
        - 虽然协议栈的实现不同，但是并不影响通讯；因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立
        - Windows 和Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同

![](/images/HowNetworksWorks/34.png)

- 连接过程
    - 连接操作的第一步是在TCP模块出创建表示连接控制信息的头部（TCP头部）；通过TCP头部中的发送方和接受方端口号可以找到要连接的套接字
    - 当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送  
    - IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器
    - 然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块
    - 服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字
    - 当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接
    - 然后 TCP 模块会返回响应到客户端，重复和客户端一样的过程
        - 服务器在返回响应的时候还需要再TCP头部设置发送方和接受方的端口号以及SYN比特，此外还要将ACK控制位设为1
            - ACK 设为1表示以及接收到相应的网络包，ACK比特就是用来确认网络包是否送达的

    - 客户端接收到响应信息并确认TCP头部信息的SYN为1,表示连接成功
    - 接着就会向套接字中写入服务器的IP地址、端口号等信息；同时将状态改为连接完毕，
    - 并将客户端的TCP头部ACK比特设置为1，发送给服务器，表明刚才的响应包已收到
    - 这样连接就全部完成

### 收发数据

#### 将 HTTP 请求信息交给协议栈
- 协议栈收到应用程序传来的数据会先存放到发送缓冲区，等到应用程序继续传送数据，避免发送大量小网络包，导致网络效率下降
- 协议栈发送数据要根据以下几个要素来判断
    - (1)每个网络包能容纳的数据长度，协议栈会根据一个叫作MTU（Maximum Transmission Unit）的参数来判断
        - MTU表示每个网络包的最大长度，在以太网中一般是1500字节
        - MTU 是包含头部的总长度，因此需要从MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作 MSS
        - 当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去

    ![](/images/HowNetworksWorks/37.png)

    - (2)时间
        - 当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到 MSS，也应该果断发送出去
        - 为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去
    - 两者其实是有矛盾的，具体如何达到平衡得看协议栈开发者
- 如果仅靠协议栈来判断发送的时机可能会带来一些问题，因此协议栈也给应用程序保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项

#### 拆分较大的数据

- 如果数据很大，比如长篇文章，这样发送缓冲区中数据长度就会超过MSS的长度
- 这样时候就不需要继续等待后面的数据了，直接以MSS长度为单位拆分
- 拆分出来的数据放进单独的网络包，在数据前面加上TCP头部，IP头部，MAC头部，然后发送

![](/images/HowNetworksWorks/38.png)

#### 使用 ACK 号确认网络包已收到

![](/images/HowNetworksWorks/39.png)

- TCP 具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能
- TCP 模块在拆分数据的时候，会对数据做好标识，让服务器能够知道数据包有没有遗漏
- 返回 ACK 号时，除了要设置 ACK 号的值以外，还需要将控制位中的 ACK 比特设为 1，这代表 ACK 号字段有效，接收方也就可以知道这个网络包是用来告知 ACK 号的
- 实际的通信序号是随机的一个初始值，固定的序号容易被预测攻击
    - 因此在收发数据之前就将初始值告诉通信对象
    - 在连接过程中将 SYN（Synchronize） 控制位设为 1 的时候，就在这一步同时设置了初始值

- 上面的只是单项的数据传输，实际上客户端向服务器发送数据的同时，服务器也在向客户端发送数据

![](/images/HowNetworksWorks/40.png)

- 实际的初始值序号和ACK确认流程如下

![](/images/HowNetworksWorks/41.png)

- 因为有了 TCP 这个机制，我们可以确认接受方有没有收到某个包，如果没有收发则重新发送
- 这样一来，无论网络中发送任何错误，我们都可以发现并重传网络包
- 因此，网卡、集线器、路由器都不需要错误补偿机制了，一旦检测到错误，直接丢弃相应的包
- 在网络中断，服务器宕机，TCP 重传不起效，TCP会在尝试几次重传无效后强制结束通信，并向应用程序报错

#### 根据网络包平均往返时间调整 ACK 号等待时间

- 前面的只是基本原理，实际上网络的错误检测和补偿机制非常复杂

- 设置一个合理的返回 ACK 号的等待时间
    - 当网络拥塞的时候，ACK 号返回速度变慢，需要将等待时间设置长点，否则就会已经重传了包之后，前面的 ACK 号才姗姗来迟
    - 重传了多余的包，数量多了之后会给本来就拥塞的网络雪上加霜
    - 设置等待时间也不是越长越好，时间过长，包的重传就会出现很大的延迟，也会导致网络速度变慢
    - 设置一个合理的值十分困难
        - 服务器的物理距离，拥塞情况，等都要考虑
    - 因此，TCP采用了动态调整等待时间的方法
        - TCP 会在发送数据的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应延长等待时间；相对地，如果 ACK 号马上就能返回，则相应缩短等待时间 

#### 使用窗口有效管理 ACK 号

![](/images/HowNetworksWorks/42.png)

- 使用滑动窗口的方式，时间是充分利用了，但是可能会出现发送包的频率超过接受方处理能力的情况
    - 接受方收到包后，会先将数据存放到接受缓冲区，然后计算ACK号，将数据块组装起来还原成数据并传递给应用程序
    - 如果前面的操作没有完成，后面下一个包到了，会被暂存在接收缓冲区等待处理
    - 如果数据到达的速率比处理这些数据并传递给应用程序的速率还要块，那么接受缓冲区中的数据越来越多，最终就会溢出
    - 后面的数据包就收不到了，也就是超出了接受方的处理能力
- 为了避免这种情况，首先接受方需要告诉发送方字节最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制

![](/images/HowNetworksWorks/43.png)

- 这个能够接收的最大数据量称为 窗口大小 ，它是 TCP 调优参数中非常有名的一个

#### ACK 与 窗口的合并

- 要提高收发数据的效率，就要考虑返回ACK号和更新窗口的时机
- 更新窗口一般在接受方缓冲区剩余容量增加时，告知对方
- ACK 号在接受到后就告知对方
- 如果这两个是单独的包，就会导致接受方给发送方的包太多，从而导致网络效率下降
- 因此，接受方会等待一段时，把两种通知的包合并在一个包发送

#### 接收 HTTP 响应消息

- 首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号
- 然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序
- 具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序
- 将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新 

### 断开服务器并删除套接字

#### 数据发送完毕后断开连接

- 服务器的协议栈会生成包含断开信息的TCP头部，将控制位中的 FIN 比特设为 1
- 接下来，协议栈会委托IP模块向客户端发送数据
- 同时，服务器的套接字中也会记录下来断开操作的相关信息

![](/images/HowNetworksWorks/44.png)

- 然后客户端接受到后，客户端的协议栈会将自己的套接字标记为进入断开操作状态
- 为了告诉服务器已经收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号

- 应用程序有可能在收到 FIN 为 1 的包之前就来读取数据，这时读取数据的操作会被挂起，等到 FIN 包到达再继续执行

#### 删除套接字

- 和服务器通信结束后，用来通信的套接字也不会再使用了
- 套接字并不会立刻被删除，而是等待一段时间之后再被删除
    - 为了防止误操作
    - 假设，客户端先发起断开，则断开的操作顺序如下
        - （1）客户端发送 FIN 
        - （2）服务器返回 ACK 号
        - （3）服务器发送 FIN 
        - （4）客户端返回 ACK 号
    - 如果最后客户端返回的 ACK 号丢失了，结果会如何呢？这时，服务器没有接收到 ACK 号，可能会重发一次 FIN。如果这时客户端的套接字已经删除了，会发生什么事呢？套接字被删除，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来。这时，如果别的应用程序要创建套接字，新套接字碰巧又被分配了同一个端口号 B，而服务器重发的 FIN 正好到达，会怎么样呢？本来这个 FIN 是要发给刚刚删除的那个套接字的，但新套接字具有相同的端口号，于是这个 FIN 就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。之所以不马上删除套接字，就是为了防止这样的误操作

#### TCP 整体流程

![](/images/HowNetworksWorks/45.png)


### IP 与以太网的包收发操作

#### 包的基本结构

- 网络包由头部和数据两部分构成
    - 头部包含了目的地址等控制信息，就和快递的地址电话一样
    - 数据就相当于快递物件

![](/images/HowNetworksWorks/46.png)

- 发送网络包的时候，发送方的网络设备会负责创建包，创建包的过程就是生成含有正确控制信息的头部，然后再附上要发送的数据

![](/images/HowNetworksWorks/47.png)

![](/images/HowNetworksWorks/48.png)

- 首先会发往最近的网络转发设备，再发往其他网络设备，层层转发，最终达到接受方的网络设备
    - 路由器根据目标地址判断下一个路由器的位置
    - 集线器在子网中将网络包传输到下一个路由
- 集线器是按照 以太网 规则传输包的设备；而路由器是按照 IP 规则传输包的设备
    - IP协议根据目标地址判断下一个IP转发设备的位置
    - 子网中的以太网协议将包传输到下一个转发设备

- TCP/IP包含有两个头部:MAC头部（用于以太网协议）；IP头部（用于IP协议）

#### 包的收发操作

- 在整个传输流程中，是由各种网络设备合力完成的；IP模块仅仅只是整个包的传输流程的入口

![](/images/HowNetworksWorks/49.png)

- 包收发操作的起点是TCP模块委托IP模块发送网络包，这个过程中TCP模块在数据块前面加上TCP头部和指定通信对象的IP地址，然后传递给IP模块
- 收到委托后，IP模块将 前面的TCP头部和数据块 当作一个整体（二进制数据），然后在头部添加IP头部和MAC头部

![](/images/HowNetworksWorks/50.png)

- 然后封装好的包会发送给网络设备，最近的就计算机的网卡；传递给网卡的网络包是二进制的
- 接着网卡将二进制的数字信息转换为电信号/光信号，通过网线/光纤发送出去
- 然后接受方收到后，逆向操作

#### 生成包含接受方 IP 地址的 IP 头部

![](/images/HowNetworksWorks/51.png)

- IP头部最重要的内容就是接受方的IP地址，这个地址是由TCP模块告知的，而TCP模块又是在执行连接操作时从应用程序那里获得这个地址的

- IP头部还需要有发送方的IP地址，这个IP地址一般大家认为是发送方的计算机IP地址
    - 实际上，IP地址不是分配给计算机的，而是分配给网卡的，当计算机有多块网卡的时候就有多个IP地址（服务器就有很多块网卡）

![](/images/HowNetworksWorks/52.png)

- 如何判断把包给那块网卡呢
    - 其实和路由器使用 IP 表判断下一个路由器位置的操作是一样的
    - 因为协议栈的 IP模块与路由器中负责包收发的部分都是根据 IP 协议规则来进行包收发操作的，所以它们也都用相同的方法来判断把包发送给谁
    - IP 表又可以叫做 路由表

![](/images/HowNetworksWorks/53.png)

- 我们对套接字中记录的目的地 IP 地址与路由表左侧的 Network Destination 栏进行比较，找到对应的一行
    - 例如，TCP 模块告知的目标 IP 地址为 192.168.1.21，那么就对应图中的第 6 行，因为它和 192.168.1 的部分相匹配
    - 如果目标 IP 地址为 10.10.1.166，那么就和 10.10.1 的部分相匹配，所以对应第 3 行
- Interface 列，表示网卡等网络接口，这些网络接口可以将包发送给通信对象
- Gateway 列表示下一个路由器的 IP 地址，将包发给这个 IP 地址，该地址对应的路由器就会将包转发到目标地址 
- 路由表的第 1 行中，目标地址和子网掩码 A 都是 0.0.0.0，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配这一行

- 最后还需要填写协议号，它标识包的内容来自哪个模块
    - TCP模块，06（十六进制）
    - UDP模块，17（十六进制）

#### 生成以太网用的 MAC 头部

![](/images/HowNetworksWorks/54.png)

- 生成了 IP 头部之后，接下来 IP 模块还需要在 IP 头部的前面加上MAC 头部
- IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里
- 但在以太网的世界中，TCP/IP 的这个思路是行不通的
- 以太网在判断网络包目的地时和 TCP/IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC 头部就是干这个用的

- MAC 头部是以太网使用的头部，它包含了接受方和发送方的 MAC 地址信息等
- IP 地址长度 32bit ; MAC 地址长度 48 bit
- 以太类型和协议号类似
    - 在IP中，协议号标识IP头部后面的包内容的类型
    - 在以太网中，可以认为以太网类类型后面就是以太网包的内容
        - 而以太类型就表示后面内容的类型
    - 以太网包的内容可以是IP、ARP等协议的包

- 以太类型，这里可以填写表示IP协议的值 0800（十六进制）
- 然后填写网卡本身的MAC地址，MAC地址是网卡生产时写入ROM里的，只要读取出来写入MAC头部就可以了

- 最后就和IP地址一样判断从那块网卡发送网络包，把这块网卡的MAC地址填进去
![](/images/HowNetworksWorks/55.png)
- 但是，接受方的MAC地址根本不知道，所以我们还需要根据IP地址查询MAC地址的操作

#### 通过 ARP 查询目标路由器的 MAC 地址

- ARP：Address Resolution Protocol 地址解析协议

- ARP 利用广播对连接在同一以太网中的所有设备查询 MAC 地址

![](/images/HowNetworksWorks/56.png)


- 如果每次发送包都要这样查询一次，网络中就会增加很多 ARP包，因此我们会将查询结果放到一块叫作 ARP 缓存的内存空间中留着以后用
- 也就是说，在发送包时，先查询一下 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址，而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 查询

![](/images/HowNetworksWorks/57.png)

![](/images/HowNetworksWorks/58.png)

- ARP缓存中的地址会在一定时间后被删除，避免读取到IP地址发生变化后造成的差异

- 将 MAC 头部加在 IP 头部前面，整个包就完成了
- 到此为止，整个打包工作是由 IP 模块完成的
    - 这样的好处是，在把数据包交给网卡之前就打包好
    - 这样一来，网卡就可以支持各种类型的包，网卡专注于收发

#### 以太网的结构

- IP 模块的工作完成后，就轮到网卡开始工作了

![](/images/HowNetworksWorks/59.png)

- 以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术
- 收发器：将不同网线之间的信号连接起来
- 尽管以太网经历了数次变迁，但其基本的 3 个性质至今仍未改变
    - 即将包发送到 MAC 头部的接收方 MAC 地址代表的目的地
    - 用发送方 MAC地址识别发送方
    - 用以太类型识别包的内容
- 因此，可以认为具备这3 个性质的网络就是以太网

#### 将 IP 包转换成电或光信号发送出去

- IP 生成的网络包只是存放在内存中的一串数字信息
- 因此，需要将数字信号转换成电信号或者光信号，才能在网线上传输
- 负责执行这个操作的就是网卡，但是网卡也无法单独工作，需要控制网卡就需要网卡驱动程序

![](/images/HowNetworksWorks/60.png)

- MAC:Media Access Control

![](/images/HowNetworksWorks/61.png)

- 可以从网卡 ROM 中读出 MAC 值 设置给 MAC 模块
- 也可以从命令或配置中读取 MAC 值
    - 这种情况下，网卡会忽略ROM 中的 MAC 地址
- 有人认为在网卡通电之后，ROM 中的 MAC 地址就自动生效了，其实不然，真正生效的是网卡驱动进行初始化时在 MAC模块中设置的那个 MAC 地址

#### 给网络包再加3个控制数据

![](/images/HowNetworksWorks/62.png)

- 网卡驱动从IP模块获取到包之后，将其复制到网卡内的缓冲区中，然后向 MAC 模块发送 “发送包” 的指令
- MAC 模块将包从缓冲区中取出，并在开头添加 报头、起始帧分节符，在末尾添加用于检测错误的帧校验序列 （历史原因，帧和包是一个意思）

- 报头是一串像 10101010…这样 1 和 0 交替出现的比特序列，长度为 56比特，它的作用是确定包的读取时机
- 当这些 1010 的比特序列被转换成电信号后，会形成如下图这样的波形
- 接收方在收到信号时，遇到这样的波形就可以判断读取数据的时机

![](/images/HowNetworksWorks/63.png)

- 用电信号来表达数字信息是，需要让0和1两种比特分别对应特定的电压和电流

![](/images/HowNetworksWorks/64.png)

- 在测量电压和电流的时候，必须先判断出每个比特的界限在哪，要不连续同种比特出现的时候就很难切分（连续1111或00000）
- 为了解决这个问题，引入一组用来区分比特间隔的时钟信号
    - 当时钟信号变化时，读取电压和电流值，和0或1对应
    - 但是距离较远时，网线较长时，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移
- 为了解决偏差，采用将数据信号和时钟信号叠加在一起的方法

#### 向集线器发送网络包

- 发送信号的操作分为两种
    - 一种是使用集线器的半双工模式
    - 另一种是使用交换机的全双工模式
- 在半双工模式中，为了避免信号碰撞，需要先判断网线中是否存在其他信号设备发送信号
    - 有则等待，没有即可发送
- 首先，MAC 模块从报头开始将数字信号按每个比特转成电信号，然后由PHY或叫MAU的信号收发模块发送出去
    - MAU：Medium Attachment Unit 介质连接单元
    - PHY：Physical Layer Device 物理层装置
    - 根据以太网的信号方式的不同，叫法不同，速度在100Mbit/s以上的以太网中都叫PHY
    - 在这里，将数字信号转换成电信号的速率就是网络传输速率
![](/images/HowNetworksWorks/65.png)
- 接下来，PHY模块会将信号转换为可以在网线上传输的格式，并通过网线发送出去
    - 以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定
    - 但 MAC 模块并不关心这些区别，而是将可转换为任意格式的通用信号发送给 PHY（MAU）模块
    - 然后 PHY（MAU）模块再将其转换为可在网线上传输的格式

![](/images/HowNetworksWorks/66.png)

- PHY不仅仅只是转换信号，还需要监控接收线路有无信号进来，避免信号碰撞
- 如果发生了信号碰撞，还会发送一段阻塞信号，通知所有发送操作停止
    - 并且根据 MAC 地址生成随机数，错开重新发送信号时间
    - 当网络拥塞的时候，发送碰撞的可能性提高
    - 多次拥塞等待后，就报告通信错误

- 另一种全双工模式，可以同时接收和发送，不会发生碰撞

#### 接收网络包


- PHY （MAU）模块会将信号转换成通用格式并发送给 MAC 模块
- MAC 模块再从头开始将信号转换为数字信息，并存放到缓冲区中
- 当到达信号的末尾时，还需要检查 FCS
- 检查 MAC 头部中接收方MAC 地址与网卡在初始化时分配给自己的 MAC 地址是否一致
- 无误后，网卡通知计算机收到了一个网络包

- 计算机并不是一直监控着网卡，需要网卡去打断计算机正在执行的任务，注意到自己，这种机制就是中断

#### 将服务器的响应包从 IP 传递给 TCP

- 首先收到包，肯定是先检查以太类型，确定是什么协议；0800就是TCP/IP
- 接着检查IP头部、查看接受方IP地址
    - 如果IP格式无误，接受方IP地址和客户端网卡地址一致，就可以接收这个包了
- 如果接受方的IP不是自己的，发生了这样的错误时，IP模块会通过ICMP消息将错误告诉发送方

![](/images/HowNetworksWorks/67.png)


### UDP协议的收发操作

#### 不需要重发的数据用 UDP 发送更高效

- TCP 设计得如此完善，就是要确保它的数据可靠性
- 如果数据很短，不用分包，一个包就足够的情况下，就不需要考虑漏包等问题了
    - 一旦丢失或未送达就重发，就就一个包，根本不影响效率
    - 这样就不需要 TCP 这么复杂的机制了
- 发送了数据，对方给出回复就可以

#### 控制用的短数据

- 像 DNS 查询等交换控制信息的操作基本上都可以在一个包的大小范围就可以解决，这种场景就可以用 UDP 来代替 TCP
    - UDP 没有 TCP 的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立建立和断开连接的步骤
    - 只需要从应用程序获取的数据前面加上 UDP 头部，然后交给 IP 模块发送就可以了

![](/images/HowNetworksWorks/68.png)

- 在线播放音频和视频数据的时候，也会使用 UDP ，因为这些数据必须在规定时间内达到，否则会错过时机，导致卡顿
    - 一旦错过时间，重发数据也没有用；
    - 在这些无需重发，或者重发也没意义的场景，用 UDP 效率更高


## 从网线到网络设备—集线器、交换机、路由器

![](/images/HowNetworksWorks/69.png)

### 信号在网线和集线器中传输

- 每个包都是独立传输的
    - 每个阶段的都不会关心上个阶段的包内部内容
    - 每个后面的阶段只会根据上阶段传输过来的包头部中的控制信息，进行操作

![](/images/HowNetworksWorks/70.png)

- 电信号会在传输过程中逐渐衰弱
    - 电信号频率越高，能量损失率越大，因此传输过程就会失真
    - 如果再加上噪音，失真就更厉害，进一步影响0，1的判断，这就是产生通信错误的原因
![](/images/HowNetworksWorks/71.png)
- 局域网使用的网线就是双绞线，双绞就是把两根信号线为一组缠绕在一起，这样就是为了抑制噪音
    - 产生噪音的原因就是网线周围的电磁波，电磁波接触到导体时会在其中产生电流，干扰原有的电流
![](/images/HowNetworksWorks/72.png)
- 影响网线的电磁波分为两种
    - 一种是电机、荧光灯、CRT显示器等设备泄露出来的电磁波，这类电磁波来自网线外部
    - 另一种是是从网线相邻的信号线泄露出来的，这类内部产生的噪音称为串扰
![](/images/HowNetworksWorks/73.png)

- 除了用“双绞”的方式外，在信号线之间加入隔板距离以及在外面包裹可阻挡电磁波的金属屏蔽网等也可以抑制信号干扰
- 网线的性能是以“类”来区分的
![](/images/HowNetworksWorks/74.png)


- 当信号到达集线器后，会被广播到整个网络中
    - 以太网的基本架构就是将包发到所有的设备
    - 然后由设备根据接收方 MAC 地址来判断应该接收哪些包，
    - 而集线器就是这一架构的忠实体现，它就是负责按照以太网的基本架构将信号广播出去
![](/images/HowNetworksWorks/75.png)

### 交换机的包转发操作

#### 交换机根据地址表进行转发














### 路由器的包转发操作


### 路由器的附加功能











## 通过接入网进入互联网内部—接入网、网络运营商

## 服务器端的局域网中有什么玄机

## 请求到达 Web 服务器，响应返回浏览器—短短几秒的“漫长旅途”迎来终点

## 网络包的路途

![](/images/HowNetworksWorks/last.png)